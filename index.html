<!DOCTYPE html>
<html>
  <head>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <title>CS416 Narrative Visualization: Health Spending Slideshow</title>
    <style>
      body { font-family: sans-serif; text-align: center; }
    </style>
  </head>

  <body>
    <h1>How Does Governmental Health Expenditure Improve Quality of Life?</h1>

    <p>
      Governments spend millions, billions, and even trillions of dollars to the improve the lives of their citizens. Much of the spending is 
      on research and development projects or defense contracts. While important issues it is unclear how important these topics are
      to the health and wellbeing of the public. This narrative visualization slideshow highlights the importance of governmental health spending
      to improve health related metrics including infant mortality, obesity rate, and life expectancy.
    </p>
    
    <div id="btns">
      <button id="prev">Prev</button>
      <button class="scene" data-scene="0">1</button>
      <button class="scene" data-scene="1">2</button>
      <button class="scene" data-scene="2">3</button>
      <button id="next">Next</button>
      <button id="toggle-quadrants">Quadrants</button>
    </div>

    <svg id="chart" width="1000" height="600"></svg>

    <script>
      const metrics = [
        { key: "infantMort", label: "Infant mortality (per 1,000 births)", invert: true  },
        { key: "obesityPct", label: "Adult obesity (%)",                  invert: false },
        { key: "lifeExp",    label: "Life expectancy (years)",            invert: false }
      ];
      const slideNotes = ["Slide 1 annotation","Slide 2 annotation","Slide 3 annotation"];
      const xTicks = [10,20,50,100,200,300,500,1000,2000,4000,8000,10000];
      const yThresholds = { infantMort: 15, obesityPct: 25, lifeExp: 75 };
      const dataUrl = "WDI Narrative Vizualization Full Stats.csv";

      const svg = d3.select('#chart');
      const W = +svg.attr("width");
      const H = +svg.attr("height");
      const RIGHT = 220;
      const M = {top: 20, right: 20, bottom: 55, left: 80};
      const iw = W - M.left - M.right - RIGHT;
      const ih = H - M.top - M.bottom;

      const x = d3.scaleLog().range([0, iw]).domain([10, 10000]);
      const y = d3.scaleLinear();
      
      const g  = svg.append("g").attr("transform", `translate(${M.left}, ${M.top})`);
      const gx = g.append("g").attr("transform", `translate(0, ${ih})`);
      const gy = g.append("g");
      const dotsG = g.append("g");
      const quadsG = g.append("g");

      const sidebarX = M.left + iw + 24;
      const legendG = svg.append("g").attr("transform", `translate(${sidebarX}, ${M.top})`);
      const noteG   = svg.append("g").attr("transform", `translate(${sidebarX}, ${M.top + 20 + 18*8})`);

      const xLabel = g.append("text").attr("x", iw/2).attr("y", ih + 40).attr("text-anchor", "middle").text("Health expenditure per capita (US$)");
      const yLabel = g.append("text").attr("transform", "rotate(-90)").attr("x", -ih/2).attr("y", -55).attr("text-anchor", "middle");
      
      let color = null;
      let scene = 0;
      let data = [];
      let regions = [];
      let xSplit = 500;
      let ySplit = null;
      let quadrantsOn = false;

      const COL = {
        year: "Time",
        country: "Country Name",
        code: "Country Code",
        region: "Region",
        xval: "Current health expenditure per capita (current US$) [SH.XPD.CHEX.PC.CD]",
        life: "Life expectancy at birth, total (years) [SP.DYN.LE00.IN]",
        infant: "Mortality rate, infant (per 1,000 live births) [SP.DYN.IMRT.IN]",
        obesity: "Male & Female Obesity Rate"
      };
      
      d3.csv(dataUrl, d3.autoType).then(rows => {
        data = rows
          .filter(d => +d[COL.year] === 2016)
          .map(d => ({
            country: d[COL.country],
            code: d[COL.code],
            region: d[COL.region],
            year: +d[COL.year],
            healthExpPC: +d[COL.xval],
            lifeExp: +d[COL.life],
            infantMort: +d[COL.infant],
            obesityPct: +d[COL.obesity]
          }))
          .filter(d => d.region && d.healthExpPC > 0 && [d.lifeExp, d.infantMort, d.obesityPct].every(Number.isFinite));

        regions = Array.from(new Set(data.map(d => d.region))).sort();
        color = d3.scaleOrdinal(regions, d3.schemeCategory10);

        gx.call(d3.axisBottom(x)
          .tickValues(xTicks.filter(v => v >= x.domain()[0] && v <= x.domain()[1]))
          .tickFormat(d => "$" + d3.format("~s")(d)));

        drawLegend();
        initNote();
        drawScene(true);
        setupNavigation();
      });

      function drawLegend(){
        legendG.selectAll("*").remove();
        legendG.append("text").attr("x",0).attr("y",0).text("Region").attr("font-size",12).attr("font-weight","bold");
        const row = legendG.selectAll("g.row").data(regions, d => d).enter()
          .append("g").attr("class","row").attr("transform", (d,i) => `translate(0, ${20 + i*18})`);
        row.append("rect").attr("width",12).attr("height",12).attr("fill", d => color(d));
        row.append("text").attr("x",18).attr("y",10).attr("font-size",12).text(d => d);
      }

      function initNote(){
        noteG.selectAll("*").remove();
        noteG.append("text").attr("x",0).attr("y",0).text("Slide notes").attr("font-size",12).attr("font-weight","bold");
        noteG.append("text").attr("id","note-text").attr("x",0).attr("y",18).attr("font-size",12).text(slideNotes[scene]);
      }

      function updateNote(){
        d3.select("#note-text").text(slideNotes[scene]);
      }

      function tooltipText(d){
        return (
          d.country + "\n" +
          "Region: " + d.region + "\n" +
          "Health exp per cap: $" + d3.format(",.0f")(d.healthExpPC) + "\n" +
          "Life expectancy: " + d3.format(".1f")(d.lifeExp) + " yrs\n" +
          "Obesity: " + d3.format(".1f")(d.obesityPct) + " %\n" +
          "Infant mortality: " + d3.format(".1f")(d.infantMort) + " / 1,000"
        );
      }

      function drawScene(initial=false){
        const def = metrics[scene];
        const extent = d3.extent(data, d => d[def.key]);
        y.domain([extent[0], extent[1]]).nice();
        y.range(def.invert ? [0, ih] : [ih, 0]);
        gy.transition().duration(initial?0:700).call(d3.axisLeft(y).ticks(8));
        yLabel.text(def.label);

        const sel = dotsG.selectAll("circle").data(data, d => d.code);

        const entered = sel.enter().append("circle")
          .attr("r", 4)
          .attr("cx", d => x(d.healthExpPC))
          .attr("cy", d => y(d[def.key]))
          .attr("fill", d=> color(d.region))
          .attr("opacity", 0.9);
        entered.append("title").text(d => tooltipText(d));

        sel.transition().duration(initial?0:700).ease(d3.easeCubicInOut)
          .attr("cx", d => x(d.healthExpPC))
          .attr("cy", d => y(d[def.key]));
        sel.select("title").text(d => tooltipText(d));

        sel.exit().remove();

        drawQuadrants();
        updateNote();
        setButtons();
      }

      function drawQuadrants(){
        quadsG.selectAll("*").remove();
        if (!quadrantsOn) return;

        const def = metrics[scene];
        const splitYVal = ySplit == null ? yThresholds[def.key] : ySplit;

        const px = x(xSplit);
        const py = y(splitYVal);

        quadsG.append("line").attr("x1", px).attr("x2", px).attr("y1", 0).attr("y2", ih).attr("stroke", "#333").attr("stroke-width", 1);
        quadsG.append("line").attr("x1", 0).attr("x2", iw).attr("y1", py).attr("y2", py).attr("stroke", "#333").attr("stroke-width", 1);

        const leftX  = (0 + px) / 2;
        const rightX = (px + iw) / 2;
        const topY   = (0 + py) / 2;
        const botY   = (py + ih) / 2;

        const topHealth  = def.invert ? "bad_health"  : "good_health";
        const botHealth  = def.invert ? "good_health" : "bad_health";

        const labels = [
          { x: leftX,  y: topY, text: "low_spending, "  + topHealth },
          { x: rightX, y: topY, text: "high_spending, " + topHealth },
          { x: leftX,  y: botY, text: "low_spending, "  + botHealth },
          { x: rightX, y: botY, text: "high_spending, " + botHealth }
        ];

        quadsG.selectAll("text.quad").data(labels).enter()
          .append("text")
          .attr("class", "quad")
          .attr("x", d => d.x)
          .attr("y", d => d.y)
          .attr("text-anchor", "middle")
          .attr("font-size", 12)
          .text(d => d.text);
      }

      function setSplits(xDollar, yValue){
        xSplit = xDollar;
        ySplit = yValue;
        drawQuadrants();
      }

      function gotoScene(s){
        const target = Math.max(0, Math.min(2, s));
        if (target !== scene){ scene = target; drawScene(); }
      }

      function setButtons(){
        document.getElementById("prev").disabled = (scene === 0);
        document.getElementById("next").disabled = (scene === 2);
      }

      function setupNavigation() {
        document.getElementById("prev").addEventListener("click", () => gotoScene(scene-1));
        document.getElementById("next").addEventListener("click", () => gotoScene(scene+1));
        document.querySelectorAll(".scene").forEach(b => b.addEventListener("click", e => gotoScene(+e.currentTarget.dataset.scene)));
        document.getElementById("toggle-quadrants").addEventListener("click", () => {
          quadrantsOn = !quadrantsOn;
          drawQuadrants();
        });
        setButtons();
      }
    </script>
  </body>
</html>
